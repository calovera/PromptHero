Now add the data contracts, Gemini wrapper, scoring and optimizing functions, background message handling, and storage helpers. Enforce strict JSON via zod. Do not hardcode API keys. Read from chrome.storage.local under "gemini_api_key".

# zod schemas (src/lib/schema.ts)
import { z } from "zod"

export const ScoreSchema = z.object({
  score: z.number().min(0).max(100),
  issues: z.array(z.string()).max(8),
  suggestions: z.array(z.string()).max(8)
})
export type Score = z.infer<typeof ScoreSchema>

export const OptimizeSchema = z.object({
  improved_prompt: z.string().min(1),
  checklist: z.array(z.string()).max(12)
})
export type Optimize = z.infer<typeof OptimizeSchema>

export type HistoryEntry = {
  original: string
  originalScore?: Score
  improved?: string
  improvedScore?: Score
  timestamp: number
}

# Storage helpers (src/lib/storage.ts)
- async function getKey(): Promise<string | null>
- async function setKey(k: string): Promise<void>
- async function saveHistory(entry: HistoryEntry): Promise<void>  // keep last 10
- async function loadHistory(): Promise<HistoryEntry[]>
- async function saveWorkingState(state: {
    prompt: string
    currentScore?: Score
    improved?: string
    improvedScore?: Score
  }): Promise<void>
- async function loadWorkingState(): Promise<{
    prompt: string
    currentScore?: Score
    improved?: string
    improvedScore?: Score
  } | null>

# Strict prompt templates (constants in src/background/gemini.ts)
SCORER_SYSTEM =
"You are a prompt quality judge. Return JSON only that passes this schema: { score: number 0..100, issues: string[], suggestions: string[] }. Scoring rubric: Clarity 25, Specificity 25, Constraints 20, Context 15, Output format 10, Token efficiency 5. Keep issues and suggestions short and actionable. No extra text."

SCORER_USER(template) =
`Evaluate this prompt.
PROMPT
${template}
Return JSON only.`

OPTIMIZER_SYSTEM =
"You are a prompt engineer. Rewrite the prompt to maximize task success while keeping the same goal. If the prompt is vague or brief, infer reasonable defaults and add missing context requests and constraints. Add clear step-by-step instructions. Specify the desired output format. Keep it concise and token-efficient. Return JSON only that passes: { improved_prompt: string, checklist: string[] }. Checklist lists what you improved. No extra text."

OPTIMIZER_USER(template) =
`Rewrite this prompt.
PROMPT
${template}
Return JSON only.`

# Gemini API wrapper (src/background/gemini.ts)
- getApiKey(): read chrome.storage.local.get("gemini_api_key")
- ensureApiKeyOrThrow()
- async function callGemini(system: string, user: string, opts?: { temperature?: number, maxTokens?: number }): Promise<string>
  - Build body: contents with a single user role whose text is `${system}\n\n${user}`
  - generationConfig: temperature and maxOutputTokens
  - POST to https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKey}
  - Return first candidate text or throw
- async function callJson<T>(system: string, user: string, schema: import("zod").ZodSchema<T>, opts?): Promise<T>
  - Try JSON.parse on callGemini result
  - On failure, retry once by appending "Return VALID JSON only. No prose." to system
  - Validate with schema.parse
- export async function scorePrompt(prompt: string): Promise<Score>
  - temperature 0.1, maxTokens 128
- export async function optimizePrompt(prompt: string): Promise<Optimize>
  - temperature 0.5, maxTokens 512

# Background message handling (src/background/background.ts)
- Listen to messages
- On SCORE_PROMPT: const data = await scorePrompt(msg.prompt); sendResponse({ ok: true, data })
- On OPTIMIZE_PROMPT: const data = await optimizePrompt(msg.prompt); sendResponse({ ok: true, data })
- Catch and return { ok: false, error: message }
- return true to keep async channel open

# Options wiring (src/options/Options.tsx)
- Save button calls setKey
- Test button:
  - Calls a super-light callGemini with system "Return JSON only: { ok: true }" and user "Return {\"ok\":true}"
  - If parse passes, show Toast "Key works"
  - Else show Toast with error

# Popup glue (non-UI yet)
- Implement functions that send messages:
  - scorePromptViaBg(text): Promise<Score>
  - optimizePromptViaBg(text): Promise<Optimize>
- Persist working state after each successful result via saveWorkingState
- Load working state on mount via loadWorkingState
- Load history on mount